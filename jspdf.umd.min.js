/**
 * Minimal jsPDF-compatible implementation for this app.
 * Provides enough of the jsPDF API to generate text-based PDFs.
 */
(function (global, factory) {
  if (typeof exports === 'object' && typeof module !== 'undefined') {
    factory(exports);
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], factory);
  } else {
    factory((global.jspdf = {}));
  }
})(typeof self !== 'undefined' ? self : this, function (exports) {
  const DEFAULT_PAGE = {
    width: 612,
    height: 792,
  };

  function escapePdfText(text) {
    return String(text)
      .replace(/\\/g, '\\\\')
      .replace(/\(/g, '\\(')
      .replace(/\)/g, '\\)')
      .replace(/\r?\n/g, ' ');
  }

  function makePage(width, height) {
    return {
      width,
      height,
      contents: [],
      fontSize: 12,
      fontStyle: 'normal',
      lineWidth: 1,
    };
  }

  class jsPDF {
    constructor() {
      const { width, height } = DEFAULT_PAGE;
      this.pages = [makePage(width, height)];
      this.currentPageIndex = 0;
      this.internal = {
        pageSize: {
          getWidth: () => width,
          getHeight: () => height,
        },
      };
    }

    get currentPage() {
      return this.pages[this.currentPageIndex];
    }

    setFontSize(size) {
      this.currentPage.fontSize = Number(size) || 12;
    }

    setFont(_name, style) {
      this.currentPage.fontStyle = style === 'bold' ? 'bold' : 'normal';
    }

    setLineWidth(width) {
      this.currentPage.lineWidth = Number(width) || 1;
    }

    text(text, x, y) {
      const page = this.currentPage;
      const fontRef = page.fontStyle === 'bold' ? 'F2' : 'F1';
      const safeText = escapePdfText(text);
      const pdfX = Number(x) || 0;
      const pdfY = page.height - (Number(y) || 0);
      page.contents.push(
        `BT /${fontRef} ${page.fontSize} Tf ${pdfX} ${pdfY} Td (${safeText}) Tj ET`,
      );
    }

    line(x1, y1, x2, y2) {
      const page = this.currentPage;
      const pdfX1 = Number(x1) || 0;
      const pdfY1 = page.height - (Number(y1) || 0);
      const pdfX2 = Number(x2) || 0;
      const pdfY2 = page.height - (Number(y2) || 0);
      page.contents.push(`${page.lineWidth} w ${pdfX1} ${pdfY1} m ${pdfX2} ${pdfY2} l S`);
    }

    addPage() {
      const { width, height } = DEFAULT_PAGE;
      this.pages.push(makePage(width, height));
      this.currentPageIndex = this.pages.length - 1;
    }

    getTextWidth(text) {
      const page = this.currentPage;
      return String(text).length * (page.fontSize * 0.5);
    }

    save(filename = 'document.pdf') {
      const pdf = this.output();
      const blob = new Blob([pdf], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = filename;
      anchor.click();
      URL.revokeObjectURL(url);
    }

    output() {
      const encoder = new TextEncoder();
      const objects = [];
      const pageObjectNumbers = [];
      const contentObjectNumbers = [];

      const objectIdForPage = (index) => 5 + index * 2;
      const objectIdForContent = (index) => 6 + index * 2;

      this.pages.forEach((page, index) => {
        pageObjectNumbers.push(objectIdForPage(index));
        contentObjectNumbers.push(objectIdForContent(index));
      });

      const kids = pageObjectNumbers.map((num) => `${num} 0 R`).join(' ');

      objects[1] = `<< /Type /Catalog /Pages 2 0 R >>`;
      objects[2] = `<< /Type /Pages /Kids [${kids}] /Count ${this.pages.length} >>`;
      objects[3] = `<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>`;
      objects[4] = `<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica-Bold >>`;

      this.pages.forEach((page, index) => {
        const pageObj = objectIdForPage(index);
        const contentObj = objectIdForContent(index);
        const content = page.contents.join('\n');
        const contentLength = encoder.encode(content).length;

        objects[pageObj] =
          `<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${page.width} ${page.height}] ` +
          `/Resources << /Font << /F1 3 0 R /F2 4 0 R >> >> /Contents ${contentObj} 0 R >>`;
        objects[contentObj] = `<< /Length ${contentLength} >>\nstream\n${content}\nendstream`;
      });

      const objCount = objects.length - 1;
      let output = '%PDF-1.4\n';
      const offsets = [0];

      for (let i = 1; i <= objCount; i += 1) {
        offsets[i] = encoder.encode(output).length;
        output += `${i} 0 obj\n${objects[i]}\nendobj\n`;
      }

      const xrefOffset = encoder.encode(output).length;
      output += `xref\n0 ${objCount + 1}\n`;
      output += '0000000000 65535 f \n';

      for (let i = 1; i <= objCount; i += 1) {
        const offset = String(offsets[i]).padStart(10, '0');
        output += `${offset} 00000 n \n`;
      }

      output += `trailer\n<< /Size ${objCount + 1} /Root 1 0 R >>\n`;
      output += `startxref\n${xrefOffset}\n%%EOF`;

      return output;
    }
  }

  exports.jsPDF = jsPDF;
});
